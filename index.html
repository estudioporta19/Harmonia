<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HexaSynth FX</title>
<style>
:root {
  --hex-size: 70px;
}
body {
  /* Estilo do corpo com gradientes e cores Dal√≠-escas */
  background: radial-gradient(circle at 50% 10%, #2a0050, #000000 70%),
              radial-gradient(circle at 80% 90%, #50002a, #000000 70%),
              linear-gradient(135deg, #000033, #330000);
  background-blend-mode: screen, overlay, multiply;
  color: white;
  font-family: 'Georgia', serif; /* Fonte com mais personalidade */
  text-align: center; margin: 0; padding: 20px;
  overflow: hidden;
}
h1 {
  /* T√≠tulo com brilho e gradiente vibrante */
  font-size: 3em;
  background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00);
  -webkit-background-clip: text;
  color: transparent;
  animation: glow 3s alternate infinite ease-in-out;
  text-shadow: 0 0 15px rgba(0, 255, 255, 0.7), 0 0 30px rgba(255, 0, 255, 0.7);
  letter-spacing: 2px;
}
@keyframes glow {
  from { filter: drop-shadow(0 0 8px #00ffff) drop-shadow(0 0 15px #ff00ff); }
  to { filter: drop-shadow(0 0 15px #ff00ff) drop-shadow(0 0 25px #ffff00); }
}

.grid { display:flex;flex-direction:column;align-items:center;gap:10px; margin-top:20px; }
.hex-row { display:flex; gap:4px; }
.hex {
  /* Estilo dos hex√°gonos com gradiente, borda e transi√ß√µes aprimoradas */
  width:var(--hex-size); height:calc(var(--hex-size)*1.1547);
  background: linear-gradient(135deg, #330066, #660033);
  clip-path:polygon(25% 0,75% 0,100% 50%,75% 100%,25% 100%,0 50%);
  display:flex;align-items:center;justify-content:center;
  cursor:pointer; position:relative;
  box-shadow:0 0 10px rgba(0,0,0,0.8);
  border: 1px solid rgba(0, 255, 255, 0.3);
  transition:transform .3s ease-out, filter .3s ease-out, box-shadow .3s ease-out, background .3s ease-out;
  font-weight: bold;
  text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
}
.hex:hover {
  /* Efeito de hover com rota√ß√£o e brilho intenso */
  transform:scale(1.15) rotate(5deg);
  filter:brightness(1.8) saturate(2);
  box-shadow: 0 0 30px #00ffff, 0 0 50px #ff00ff;
  background: linear-gradient(135deg, #00ffff, #ff00ff);
}
.hex.active::before {
  /* Anima√ß√£o de pulsa√ß√£o mais proeminente */
  content:'';position:absolute;inset:-8px;
  background:radial-gradient(circle,#00ffff 20%,transparent 70%);
  border-radius:20px;
  animation:pulse 0.8s infinite alternate;
  opacity: 0.7;
}
@keyframes pulse {
  0%{opacity:0.3; transform: scale(0.8);}
  50%{opacity:0.6; transform: scale(1.1);}
  100%{opacity:0.3; transform: scale(0.8);}
}
.controls {
  /* Controles com fundo semi-transparente e sombra interna */
  margin-top:40px;
  display:flex;justify-content:center;gap:30px;
  flex-wrap:wrap;
  padding: 20px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 15px;
  box-shadow: inset 0 0 15px rgba(0, 255, 255, 0.2);
}
.knob-group {
  color:#00ffff;
  text-shadow: 0 0 5px #00ffff;
  display:flex;flex-direction:column;align-items:center;
}
.knob-group label { margin-bottom:8px; font-size: 1.1em; }
.knob-group input[type="range"] {
  /* Estilo dos sliders (knobs) */
  -webkit-appearance: none;
  width: 100px;
  height: 8px;
  background: #333;
  border-radius: 5px;
  outline: none;
  opacity: 0.7;
  transition: opacity .2s;
  box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
}
.knob-group input[type="range"]:hover {
  opacity: 1;
}
.knob-group input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  background: linear-gradient(45deg, #00ffff, #ff00ff);
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 10px #00ffff;
}
.knob-group input[type="range"]::-moz-range-thumb {
  width: 20px;
  height: 20px;
  background: linear-gradient(45deg, #00ffff, #ff00ff);
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 10px #00ffff;
}

.upload-label {
  /* Estilo do bot√£o de upload com gradiente e sombra luminosa */
  padding:12px 25px;
  background:linear-gradient(90deg,#00ffff,#0000ff);
  color:#000; border-radius:25px;
  cursor:pointer; margin-bottom:25px;
  display:inline-block; transition:transform .2s, box-shadow .2s;
  font-weight: bold;
  text-transform: uppercase;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
}
.upload-label:hover {
  transform:scale(1.08);
  box-shadow: 0 0 25px #00ffff, 0 0 40px #0000ff;
}
input[type=file] { display:none; }
</style>
</head>
<body>
<h1>‚¨¢ HexaSynth FX ‚¨¢</h1>
<label class="upload-label" for="fileInput" id="uploadLabel">üéß Carregar Sample</label>
<input type="file" id="fileInput" accept="audio/*">

<div class="controls">
  <div class="knob-group">
    <label for="reverbKnob">Reverb</label>
    <input type="range" id="reverbKnob" min="0" max="1" step="0.01" value="0">
  </div>
  <div class="knob-group">
    <label for="delayKnob">Delay</label>
    <input type="range" id="delayKnob" min="0" max="0.5" step="0.01" value="0">
  </div>
  <div class="knob-group">
    <label for="filterKnob">Filtro LP</label>
    <input type="range" id="filterKnob" min="500" max="10000" step="100" value="10000">
  </div>
  <div class="knob-group">
    <label for="distKnob">Distor√ß√£o</label>
    <input type="range" id="distKnob" min="0" max="1000" step="10" value="0">
  </div>
</div>

<div class="grid" id="hexGrid"></div>

<script>
// Setup √°udio
let ctx = new (AudioContext||webkitAudioContext)();
let buffer = null;

// Chain de efeitos
let master = ctx.createGain();
let convolver = ctx.createConvolver();
let convolverGain = ctx.createGain(); // Adicionado para controle de volume do reverb
let delay = ctx.createDelay();
let delayFB = ctx.createGain();
let filter = ctx.createBiquadFilter();
let dist = ctx.createWaveShaper();

filter.type = 'lowpass'; filter.frequency.value = 10000;
delay.delayTime.value = 0; delayFB.gain.value = 0;
dist.curve = makeDistCurve(0);
convolver.normalize = true; // Normaliza√ß√£o do convolver definida uma vez
convolverGain.gain.value = 0; // Come√ßa com o reverb desligado

// Conex√µes da cadeia de efeitos
master.connect(convolver);
convolver.connect(convolverGain);
convolverGain.connect(filter);

master.connect(delay);
delay.connect(delayFB);
delayFB.connect(delay);
delay.connect(filter);

master.connect(filter); // Master tamb√©m conecta diretamente ao filtro (para sinal dry)

filter.connect(dist);
dist.connect(ctx.destination);

// reverb IR simples
fetch('https://webaudioapi.com/samples/audio-param/M1073.wav')
  .then(r=>r.arrayBuffer())
  .then(b=>ctx.decodeAudioData(b))
  .then(d=>convolver.buffer = d)
  .catch(e => console.error("Erro ao carregar o impulso do reverb:", e)); // Tratamento de erro

// criar hex√°gonos
const notes = ['C','D','E','G','A']; // Notas para display
const notesInScale = [0, 2, 4, 7, 9]; // Semitons para transposi√ß√£o (C, D, E, G, A)

function createGrid(){
  let grid = document.getElementById('hexGrid');
  const gridPattern = [
    { count: 4, offset: false },
    { count: 5, offset: true },
    { count: 4, offset: false },
    { count: 5, offset: true }
  ];
  let idx=0;
  gridPattern.forEach((rowInfo, rowNum)=>{
    let rowDiv = document.createElement('div'); rowDiv.className='hex-row';
    if(rowInfo.offset) rowDiv.style.marginLeft='calc(var(--hex-size)/2)';
    for(let i=0;i<rowInfo.count;i++){
      let h = document.createElement('div');
      h.className = 'hex'; h.dataset.idx = idx;
      let n1 = notes[idx % notes.length], n2 = notes[(idx+3)%notes.length];
      h.textContent = n1+'+'+n2;
      h.addEventListener('mousedown',()=>{
        playHex(idx); h.classList.add('active');
      });
      h.addEventListener('mouseup',()=>h.classList.remove('active'));
      h.addEventListener('mouseleave',()=>h.classList.remove('active'));
      rowDiv.appendChild(h);
      idx++;
    }
    grid.appendChild(rowDiv);
  });
}
createGrid();

// Carregar file
document.getElementById('fileInput').onchange = async e=>{
    let f = e.target.files[0];
    if (!f) return;

    const uploadLabel = document.getElementById('uploadLabel');
    uploadLabel.textContent = 'Carregando...';

    try {
        let arr = await f.arrayBuffer();
        buffer = await ctx.decodeAudioData(arr);
        uploadLabel.textContent = '‚úÖ Sample Carregado!';
        setTimeout(() => {
            uploadLabel.textContent = 'üéß Carregar Sample';
        }, 3000);
    } catch (error) {
        console.error("Erro ao decodificar o arquivo de √°udio:", error);
        uploadLabel.textContent = '‚ùå Erro ao Carregar!';
        alert("N√£o foi poss√≠vel carregar o arquivo de √°udio. Por favor, tente outro formato.");
        setTimeout(() => {
            uploadLabel.textContent = 'üéß Carregar Sample';
        }, 3000);
    }
};

// calculo disto
function makeDistCurve(amount){
  let k = typeof amount=='number'?amount:50;
  let n=44100; let curve = new Float32Array(n);
  let deg = Math.PI/180;
  for(let i=0;i<n;i++){
    let x = i*2/n -1;
    curve[i] = (3+k)*x*20*deg/(Math.PI + k*Math.abs(x));
  }
  return curve;
}

// knobs listeners
document.getElementById('reverbKnob').oninput = e=>{
  convolverGain.gain.value = parseFloat(e.target.value);
};
document.getElementById('delayKnob').oninput = e=>{
  delay.delayTime.value = parseFloat(e.target.value);
  delayFB.gain.value = parseFloat(e.target.value);
};
document.getElementById('filterKnob').oninput = e=>{
  filter.frequency.value = parseFloat(e.target.value);
};
document.getElementById('distKnob').oninput = e=>{
  dist.curve = makeDistCurve(parseFloat(e.target.value));
};

// tocar notas
function playHex(idx){
  if(!buffer) return;

  const baseMidiNote = 60; // Assumindo que seu sample √© um C4 (MIDI 60). Ajuste conforme seu sample.

  // Determinar a linha para o c√°lculo da oitava
  let row = 0;
  if (idx >= 4 && idx < 9) row = 1;
  else if (idx >= 9 && idx < 13) row = 2;
  else if (idx >= 13) row = 3;

  let noteIdx1 = idx % notesInScale.length;
  let noteIdx2 = (idx + 3) % notesInScale.length;

  let midiNote1 = baseMidiNote + (row * 12) + notesInScale[noteIdx1];
  let midiNote2 = baseMidiNote + (row * 12) + notesInScale[noteIdx2];

  let sems = [midiNote1, midiNote2];

  sems.forEach((s,i)=>{
    let src = ctx.createBufferSource();
    src.buffer = buffer;
    src.playbackRate.value = Math.pow(2, (s - baseMidiNote) / 12); // Transposi√ß√£o
    src.connect(master);
    src.start(ctx.currentTime + i*0.03); // Pequeno atraso para a segunda nota
    src.stop(ctx.currentTime + 2); // Dura 2 segundos
  });
}

// Mapeamento de teclas QWERTY para √≠ndices dos hex√°gonos
const keyToHexMap = {
    'q': 0, 'w': 1, 'e': 2, 'r': 3,
    'a': 4, 's': 5, 'd': 6, 'f': 7, 'g': 8,
    'z': 9, 'x': 10, 'c': 11, 'v': 12,
    'u': 13, 'i': 14, 'o': 15, 'p': 16,
    'k': 17
};

// Armazenar o estado das teclas para evitar repeti√ß√µes indesejadas ao segurar
const activeKeys = new Set();

document.addEventListener('keydown', (event) => {
    const key = event.key.toLowerCase();

    // Evita acionar se o foco estiver num input (como os knobs)
    if (event.target.tagName === 'INPUT') {
        return;
    }

    if (keyToHexMap.hasOwnProperty(key) && !activeKeys.has(key)) {
        const hexIdx = keyToHexMap[key];
        const hexElement = document.querySelector(`.hex[data-idx="${hexIdx}"]`);

        if (hexElement) {
            playHex(hexIdx);
            hexElement.classList.add('active');
            activeKeys.add(key);
        }
    }
});

document.addEventListener('keyup', (event) => {
    const key = event.key.toLowerCase();

    if (keyToHexMap.hasOwnProperty(key) && activeKeys.has(key)) {
        const hexIdx = keyToHexMap[key];
        const hexElement = document.querySelector(`.hex[data-idx="${hexIdx}"]`);

        if (hexElement) {
            hexElement.classList.remove('active');
            activeKeys.delete(key);
        }
    }
});
</script>
</body>
</html>
