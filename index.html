<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HexaSynth FX</title>
<style>
:root {
  --hex-size: 70px;
}
body {
  background: radial-gradient(circle, #141428, #090918);
  color: white; font-family: sans-serif;
  text-align: center; margin: 0; padding: 20px;
}
h1 {
  font-size: 2.5em;
  background: linear-gradient(45deg,#0ff,#f0f);
  -webkit-background-clip: text; color: transparent;
  animation: glow 2s alternate infinite;
}
@keyframes glow { from{filter:drop-shadow(0 0 5px #0ff)}
                   to{filter:drop-shadow(0 0 20px #f0f);} }

.grid { display:flex;flex-direction:column;align-items:center;gap:10px; margin-top:20px; }
.hex-row { display:flex; gap:4px; }
.hex {
  width:var(--hex-size); height:calc(var(--hex-size)*1.1547);
  background:#222244; clip-path:polygon(25% 0,75% 0,100% 50%,75% 100%,25% 100%,0 50%);
  display:flex;align-items:center;justify-content:center;
  cursor:pointer; position:relative;
  box-shadow:0 0 5px #000;
  transition:transform .2s,filter .2s, box-shadow .2s;
}
.hex:hover { transform:scale(1.1); filter:brightness(1.5) saturate(1.5);
             box-shadow: 0 0 20px #0ff; }
.hex.active::before {
  content:'';position:absolute;inset:-6px;
  background:radial-gradient(circle,#0ff 20%,transparent 70%);
  border-radius:15px;
  animation:pulse 1s infinite;
}
@keyframes pulse {
  0%{opacity:0.2;}50%{opacity:0.5;}100%{opacity:0.2;}
}
.controls { margin-top:20px; display:flex;justify-content:center;gap:15px; flex-wrap:wrap; }
.knob-group { display:flex;flex-direction:column;align-items:center;color:#0ff; }
.knob-group label { margin-bottom:5px; }
.knob-group input { width:80px; }

.upload-label { padding:10px 20px; background:linear-gradient(90deg,#0ff,#00f);
  color:#000; border-radius:20px; cursor:pointer; margin-bottom:20px;
  display:inline-block; transition:transform .2s;
}
.upload-label:hover { transform:scale(1.05); }
input[type=file] { display:none; }
</style>
</head>
<body>
<h1>⬢ HexaSynth FX ⬢</h1>
<label class="upload-label" for="fileInput" id="uploadLabel">🎧 Carregar Sample</label>
<input type="file" id="fileInput" accept="audio/*">

<div class="controls">
  <div class="knob-group">
    <label for="reverbKnob">Reverb</label>
    <input type="range" id="reverbKnob" min="0" max="1" step="0.01" value="0">
  </div>
  <div class="knob-group">
    <label for="delayKnob">Delay</label>
    <input type="range" id="delayKnob" min="0" max="0.5" step="0.01" value="0">
  </div>
  <div class="knob-group">
    <label for="filterKnob">Filtro LP</label>
    <input type="range" id="filterKnob" min="500" max="10000" step="100" value="10000">
  </div>
  <div class="knob-group">
    <label for="distKnob">Distorção</label>
    <input type="range" id="distKnob" min="0" max="1000" step="10" value="0">
  </div>
</div>

<div class="grid" id="hexGrid"></div>

<script>
// Setup áudio
let ctx = new (AudioContext||webkitAudioContext)();
let buffer = null;

// Chain de efeitos
let master = ctx.createGain();
let convolver = ctx.createConvolver();
let convolverGain = ctx.createGain(); // Adicionado para controle de volume do reverb
let delay = ctx.createDelay();
let delayFB = ctx.createGain();
let filter = ctx.createBiquadFilter();
let dist = ctx.createWaveShaper();

filter.type = 'lowpass'; filter.frequency.value = 10000;
delay.delayTime.value = 0; delayFB.gain.value = 0;
dist.curve = makeDistCurve(0);
convolver.normalize = true; // Normalização do convolver definida uma vez
convolverGain.gain.value = 0; // Começa com o reverb desligado

// Conexões da cadeia de efeitos
master.connect(convolver);
convolver.connect(convolverGain); // Conecta o convolver ao seu gain
convolverGain.connect(filter);    // Conecta o gain do convolver ao filtro

master.connect(delay);
delay.connect(delayFB);
delayFB.connect(delay);
delay.connect(filter); // Delay também conecta ao filtro

master.connect(filter); // Master também conecta diretamente ao filtro (para Dry signal)

filter.connect(dist);
dist.connect(ctx.destination);
// Não conectar master diretamente a ctx.destination se todos os caminhos passarem pelos efeitos
// Se quiser um sinal 'dry' misturado, mantenha: master.connect(ctx.destination);
// Mas para o setup atual, todos os sinais passam pelo filtro antes da distorção e saída.

// reverb IR simples
fetch('https://webaudioapi.com/samples/audio-param/M1073.wav')
  .then(r=>r.arrayBuffer())
  .then(b=>ctx.decodeAudioData(b))
  .then(d=>convolver.buffer = d)
  .catch(e => console.error("Erro ao carregar o impulso do reverb:", e)); // Tratamento de erro

// criar hexágonos
const notes = ['C','D','E','G','A']; // Notas para display
const notesInScale = [0, 2, 4, 7, 9]; // Semitons para transposição (C, D, E, G, A)

function createGrid(){
  let grid = document.getElementById('hexGrid');
  const gridPattern = [
    { count: 4, offset: false },
    { count: 5, offset: true },
    { count: 4, offset: false },
    { count: 5, offset: true }
  ];
  let idx=0;
  gridPattern.forEach((rowInfo, rowNum)=>{
    let rowDiv = document.createElement('div'); rowDiv.className='hex-row';
    if(rowInfo.offset) rowDiv.style.marginLeft='calc(var(--hex-size)/2)';
    for(let i=0;i<rowInfo.count;i++){
      let h = document.createElement('div');
      h.className = 'hex'; h.dataset.idx = idx;
      let n1 = notes[idx % notes.length], n2 = notes[(idx+3)%notes.length];
      h.textContent = n1+'+'+n2;
      h.addEventListener('mousedown',()=>{
        playHex(idx); h.classList.add('active');
      });
      h.addEventListener('mouseup',()=>h.classList.remove('active'));
      h.addEventListener('mouseleave',()=>h.classList.remove('active'));
      rowDiv.appendChild(h);
      idx++;
    }
    grid.appendChild(rowDiv);
  });
}
createGrid();

// Carregar file
document.getElementById('fileInput').onchange = async e=>{
    let f = e.target.files[0];
    if (!f) return;

    const uploadLabel = document.getElementById('uploadLabel');
    uploadLabel.textContent = 'Carregando...';

    try {
        let arr = await f.arrayBuffer();
        buffer = await ctx.decodeAudioData(arr);
        uploadLabel.textContent = '✅ Sample Carregado!';
        setTimeout(() => {
            uploadLabel.textContent = '🎧 Carregar Sample';
        }, 3000);
    } catch (error) {
        console.error("Erro ao decodificar o arquivo de áudio:", error);
        uploadLabel.textContent = '❌ Erro ao Carregar!';
        alert("Não foi possível carregar o arquivo de áudio. Por favor, tente outro formato.");
        setTimeout(() => {
            uploadLabel.textContent = '🎧 Carregar Sample';
        }, 3000);
    }
};

// calculo disto
function makeDistCurve(amount){
  let k = typeof amount=='number'?amount:50;
  let n=44100; let curve = new Float32Array(n);
  let deg = Math.PI/180;
  for(let i=0;i<n;i++){
    let x = i*2/n -1;
    curve[i] = (3+k)*x*20*deg/(Math.PI + k*Math.abs(x));
  }
  return curve;
}

// knobs listeners
document.getElementById('reverbKnob').oninput = e=>{
  // O valor do knob controla o ganho do convolver, misturando o reverb
  convolverGain.gain.value = parseFloat(e.target.value);
};
document.getElementById('delayKnob').oninput = e=>{
  delay.delayTime.value = parseFloat(e.target.value);
  delayFB.gain.value = parseFloat(e.target.value);
};
document.getElementById('filterKnob').oninput = e=>{
  filter.frequency.value = parseFloat(e.target.value);
};
document.getElementById('distKnob').oninput = e=>{
  dist.curve = makeDistCurve(parseFloat(e.target.value));
};

// tocar notas
function playHex(idx){
  if(!buffer) return;

  const baseMidiNote = 60; // Assumindo que seu sample é um C4 (MIDI 60). Ajuste conforme seu sample.

  // Determinar a linha para o cálculo da oitava
  let row = 0;
  if (idx >= 4 && idx < 9) row = 1; // Linha 1 (índices 4-8)
  else if (idx >= 9 && idx < 13) row = 2; // Linha 2 (índices 9-12)
  else if (idx >= 13) row = 3; // Linha 3 (índices 13-17)

  let noteIdx1 = idx % notesInScale.length;
  let noteIdx2 = (idx + 3) % notesInScale.length; // Segunda nota, um intervalo fixo

  let midiNote1 = baseMidiNote + (row * 12) + notesInScale[noteIdx1];
  let midiNote2 = baseMidiNote + (row * 12) + notesInScale[noteIdx2];

  let sems = [midiNote1, midiNote2];

  sems.forEach((s,i)=>{
    let src = ctx.createBufferSource();
    src.buffer = buffer;
    src.playbackRate.value = Math.pow(2, (s - baseMidiNote) / 12); // Transposição
    src.connect(master);
    src.start(ctx.currentTime + i*0.03); // Pequeno atraso para a segunda nota
    src.stop(ctx.currentTime + ctx.currentTime + 2); // Dura 2 segundos
  });
}

// Mapeamento de teclas QWERTY para índices dos hexágonos
const keyToHexMap = {
    'q': 0, 'w': 1, 'e': 2, 'r': 3, // Primeira linha (4 hexágonos)
    'a': 4, 's': 5, 'd': 6, 'f': 7, 'g': 8, // Segunda linha (5 hexágonos)
    'z': 9, 'x': 10, 'c': 11, 'v': 12, // Terceira linha (4 hexágonos)
    'u': 13, 'i': 14, 'o': 15, 'p': 16, // Quarta linha (4 hexágonos, ajustado para 16)
    // Se você tiver 5 hexágonos na última linha, adicione 'k': 17
    'k': 17
};

// Armazenar o estado das teclas para evitar repetições indesejadas ao segurar
const activeKeys = new Set();

document.addEventListener('keydown', (event) => {
    const key = event.key.toLowerCase();

    // Evita acionar se o foco estiver num input (como os knobs)
    if (event.target.tagName === 'INPUT') {
        return;
    }

    if (keyToHexMap.hasOwnProperty(key) && !activeKeys.has(key)) {
        const hexIdx = keyToHexMap[key];
        const hexElement = document.querySelector(`.hex[data-idx="${hexIdx}"]`);

        if (hexElement) {
            playHex(hexIdx);
            hexElement.classList.add('active');
            activeKeys.add(key);
        }
    }
});

document.addEventListener('keyup', (event) => {
    const key = event.key.toLowerCase();

    if (keyToHexMap.hasOwnProperty(key) && activeKeys.has(key)) {
        const hexIdx = keyToHexMap[key];
        const hexElement = document.querySelector(`.hex[data-idx="${hexIdx}"]`);

        if (hexElement) {
            hexElement.classList.remove('active');
            activeKeys.delete(key);
        }
    }
});
</script>
</body>
</html>
